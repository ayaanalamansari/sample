import math

from django.utils.encoding import force_text
from django.utils.translation import ugettext_lazy as _
from django.utils.translation import ungettext

from rest_framework import status, exceptions
from rest_framework.views import exception_handler


def get_from_data(data):
    errors = []

    if type(data) == dict:
        for key, value in data.items():
            value_list = get_from_data(value)
            errors.append("%s: %s" %(key, " ".join(value_list)))

    elif type(data) == list:
        value_list = []
        for d in data:
            value_list += get_from_data(d)
        return value_list

    elif type(data) == str:
        data = [str(data)]
        return data

    elif type(data) == exceptions.ErrorDetail:
        data = [str(data)]
        return data

    return errors


def custom_exception_handler(exc, context):
    """
    Note that the exception handler will only be called for responses generated by raised exceptions. It will not be used for any responses returned directly by the view, such as the HTTP_400_BAD_REQUEST responses that are returned by the generic views when serializer validation fails.
    """
    # Call REST framework's default exception handler first,
    # to get the standard error response.
    response = exception_handler(exc, context)

    # Now add the HTTP status code to the response.
    if response is not None:
        response_dct = response.data
        errors = []

        for field, value in response_dct.items():
            try:
                errors += get_from_data(value)
            except Exception as e:
                pass

        response.data['detail'] = errors
        response.data['status_code'] = response.status_code

    return response
